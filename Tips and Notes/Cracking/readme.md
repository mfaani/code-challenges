## Special situations 
- What's the hardest bug you've faced? (Pg. 15) 
- Leadership questions (Pg. 17): 
 - situation handling
 - prioritization. Making trade offs
 - communication
 - gettting the job done 
- Questions aren't meant to be about math and probability. (Pg. 23) They're meant to be about algorithms and problem solving `a^3 + b^3 = c^3 + d^3`
## Before the Interview
- For people without experience (Pg. 26): 
 - Big Projects in school 
 - Internship
 - Start something
- Don't forget: Stumbling and struggling is normal ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è (Pg. 31) 

## Behavioral Question

Make sure for each project you can talk about: 
 - Challenges
 - Mistakes/Failures
 - Enjoyed
 - Leadership (where you played a central role)
 - Conflicts
 - What'd you'd do differently 
 - Technical depth (my knowledge or access token and refresh token, app startup helped me in lots of discussions around needing access token and stuff). "I can go into more details if needed" üòÖ

If asked about your weakness, give a real example but also one that's a two sided sword üòÖ. e.g. "I forget details...which allows me to execute things quickly :D" 


"You're interviewing them as much as they're interviewing you
Everybody I spoke to emphasized how collaborative the company is, so it sounds like it helps to be comfortable reaching out to others in the company if you have questions
I didn't produce a perfectly optimal or tidy answer for most of my coding questions, but my speaking aloud about pros and cons, future improvements, areas of uncertainty seemed to delight the interviewers
When it came to discussing previous impact I've had on team, I went to great lengths to demonstrate the ability to compromise based on constraints like time and technical requirements. Basically it's fine not to create the perfect thing as long as all stakeholders are informed about the trade offs.
It certainly won't hurt your chances to demonstrate a passion for Apple. - Jon"

## Mistakes: 
 - Ziyad mandan. Agar jaye pishraft kam shode, narazi hasti, bayad beri...
 - Being less humble as I grow technically
 - Not Pushing back against band aid changes. Because as soon as something gets shipped ‚Äî it gets de-prioritized¬†‚Äî¬†because things are working.
 - Don't push too much change too quick. The more you've brought stability, the more you've earned trust, then you can make changes. Trust is like a currency build over time. Attempting to make changes without that currency will cause you damage. 
 - Not making tradeoffs. Often if something is undeliverable, or not clearly defined, I end up fighting things rather than making tradeoffs. Example with Syft, I was aiming to get in something that wasn't their priority and pushing for our priority. Priorites need to align. If not, you'll fail. 
 - Not having aligned priorities. Example: You need another team to help you with C, but the other team has committed to only A,B till the end of the year. You end up basically wasting time, trying to push for C (as an engineer) while it should be pushed ahead through your manager _first_
 - Every team, manager, team lead is different. It's wrong to desire them to match yours. Same for them. You should find some middle ground. Often their initial weaknesses may turn into their strenghts...
 - In every team you enter, try to find the **problem-solver** of the team. Don't discuss issues with the problem-creator. 
 - Trying to do a big ticket all in one go. Not breaking it down. 
 - Don't be **shy** to ask in a Public channel. It's often better because you'll hear mutliple views and get to a consensus sooner. Especially that you're working in parallel with Android. 
 - Don't stress your peers. Don't stress your lead by too many questions. Or by asking (good) questions that they are likely not to know the answer. Let everyone be comfortable with it. 
 - If something **slows you down**, don't feel depressed. You must be doing it slowly for a good reason. It's often an indicator that the task is new for you or you actually need time for things to soak in. Don't rush, nor lose hope. Be able to explain the reason. 
 - I often **think too much** and don't pull in my leads in a timely manner. 
 - When I'm frustraded due to incorrect managerial decisions e.g. rushing things, I actually become slower and feel like my slowness is justified. It shouldn't be. Their fault is their fault. I shouldn't let that slow me down. I should just work harder and fix things in the long run. Like outline a plan and talk with the right-minded people to get things done. 
 - Attempting to change/correct things, **before earning trust of your peers + understanding the current architecture/system**. Doing things too quick will cause failure.
 - If you're unfamiliar with the architecture and pick up a story that requires you to change the archtiecture or understand it fully and then be able to make changes then either communicate that with your manager or team member...
 - If someone isn't meeting with me, then I have to **create the meeting invite**, I can't just say they were suppose to create the meeting
 - I became SME in certain domains, yet I should have **created proper architectural diagrams** and linked them at the right place i.e. I should have becamet the document champion of that subject too, not just the SME. Being an SME will effect your timings
 - Ever since we had attrition I had to spend more time outside my immediate team helping other teams due to having knowledge on app startup up. I should have **managed my time bettter** and communicated better with my manager
 - Not being super **attentive in meetings** e.g. in Grooming 
 - If your tech lead isn't there technically then **instead of fighting** them for their lack of knowledge, **help them out all the way** ‚Äî¬†pateintly and while you implicitly acknowledge their work experience. Don't lose patience or get frustrated. 
 -  Often times I have ideas and I should **show a sample code of how it works** instead of just talking about
 -  I didn't have the courage to **create engineering tickets** and bring them into our sprint. I was always held back by product oriented tickets.
 -  I was always fine with lastScreenSeen. This effected the delivery of the tickets. I should have communicated it better that it would effect the on-time delivery of things. 
 -  Didn't prioritize bugs (from recent work) over new tickets. Basically a bug from work in current sprint should be prioritized over new work. 
 -  **Adapting to negative** change i.e. if you move from one squad to another and that squad has bad workflow, then don't be sad. Work hard and ignore it. 
 -  **Not every manager/lead is the same**. Some leads will come and check on you and help you out upon a tiny show of weakness, for others you need to be very articulate with their time. You just have to adapt on day one. Possibly even asking these questions from your manager/lead would save you a lot of headache.
 -  **Not sitting down enought with Product members**. Building relationship is a 2-way thing. And if they're not creating tickets in a way you need, then sit down with them and discuss things. e.g. rather than saying updaing a random flag, mentioning that's a config or firebase feature flag, helps. Basically ask them to be explicit.
 -  **Discuss How I feel about a challenging person** with someone I trust. Often speaking to another person, you realize you're at fault yourself (too). Validate your feelings about that person. Give it about 1 year to make it sure you know a person in full-remote environment vs. 6 months in person. Things are a lot more difficult to guage when you're remote!

## Leadership
- **Brining a focus** for my team. Example our squad shouldn't have a big initiative for SwiftUI, critical fixes of 2 other features and Splunk dashboard and then also pre-grooming of another Epic. 
- Idenfied bad API design. Example our ActivationResponse required client to do extensive logic handling on client side only to figure out what's the devices the user is eligible for activation. We worked with platform to make the API more clear and have them do the calculations. This brought parity between Android and iOS. 
- Understand the difference between having a source of truth vs. being the SME. 
  - You never want to be a source of truth. Documents should be. 
  - If people have proposals/questions refer them to the document. Don't try to answer/consume it all. Let the document...the source of truth do that. 
  - In order to remain SME, follow all conversations/updates. Overtime do this less. let the document grow. This is the biggest growth you can have. 
- Learning not only about my client code. But also learning about Teams & People around that we work with. 
 - Learn about Platform people. Learn about CI/CD team. 
 - Figure out how two old APIs are replaced with one. tldr if 
   1. Server is capable returning correct result for both APIs. Often a server doesn't have the needed information.
   2. Client is able to send information (to server) for both items at the needed time. Often client cant' pass some info until 2-3 screens later. 
   3. Addressing the need of either of the old APIs won't impact the latency of the other. Often returning a response for API-a takes 0.5 seconds while it takes 10 seconds for API-b. 
- Idenfied bad API design. Example our ActivationResponse required client to do extensive logic handling on client side only to figure out what's the devices the user is eligible for activation. We worked with platform to make the API more clear and have them do the calculations. This brought parity between Android and iOS. 
- Leaders can't be late to meetings. They can't be late to adopting new things. If you are then bad standards will get set...and by the time you want to change them, they'll be considered as a re-do. Previous efforst would be lost. People won't like you because you're changing their way of doing things. 
- Enforcing diagrams when I'm a new hire.
- Even often help the meeting **stay on time**. Make everyone respect the time. 
- Instead of suggesting ideas and never following up for them to happen: I created (epic) tickets, added justification and pulled them into the sprint. 
- I created a channel where everyone can share their thoughts
- I mentored folks and gave a number of talks internally
- Steered meeting conservations ‚Äî when needed. Example: When someone was trying to continue a long talk during Grooming, then instead of saying: "Hey, we can't talk about this anymore?", I say "Hey do you think we can continue this conversation ‚Äî so we can get to the rest of the tickets" i.e. instead of _instructing_ someone, we _ask_ them nicely. 
- Make sure iOS and Android **roadmaps are aligned**. Make sure client and platform roadmaps.
- I've faciliated a brown bag at work and ask folks to come and do the talks. 
- I give thanks/shout outs/ encouragements publicly but also I give feedback to folks on stuff. 
   - Proper communication for making engineer initiatives happen and proper communication of a heavily product heave focused team: 
   - This is the **complexity of our stuff**, there's multiple devices, accounts, flows, identification methods and its complex. 
   - list down everything with everyone
   - sit down with product
   - inform them of the benefits of why getting this right 
   - communicate with them the time that we need and the duration that we can't take in new features...
   - have direct contanct in a meeting with the PM. It shouldn't be someone passing the info around and it shouldn't be in a private conversation
 - Not properly communicating to manager/PM but then later spending time on stuff I thought was severly necessary. Like I should have more trust in myself that my decisions are right. Because more than often I've ended up doing that work later when my memory wasn't fresh and it had become a priority and then things got rushed...
- With terrible mistakes, there's always great room for showing great strength. Example: 
 - Someone terrible at coding, bringing up issues. Instead of getting angry, not helping, ignoring the person, coach them, pair with them, mentor them. 
 - Some terrible code, crash...Great chance to fix the code. 
- When some is being terrible (at explaining the problem, writing a document, writing a ticket, pushing up a PR), then that's not a good time for letting them go. Instead: 
 - It's actually the best time to give them help ‚Äî without being explicit that you're helping them. They're not stupid. They'll see the kindness in what you did for them. Ex: A dev asks a question about their CI job failing ‚Äî without ever linking the CI job itself. Instead of saying "well I need the link. Why didn't you share the link", just say: "I can take a look. Can you please share the link?" Make people/devs/product managers LOVE YOU. 
 
 ## Arch
 - Having an app that works at the same time with old API and new API is bad. 


### Questions to ask from interviewer: 

- What are some of features that you've shipped in the last 3 months?
- How **many devs/testers**
- What do you like about your **team? Product? Company? **
- What's your **PR merge rule **like
- What's the onboarding like? Like if I know Swift, UIKit and MVVM can I jump straight in? 
- How's your **company's presence** in the iOS community? How many of you are active speakers? How do they get support from the company? 
- Why did you choose the company? 
- What new things have you tried? What makes you think you're a tech company? And not just focused on shipping a feature and making product happy?!

- Using technology X, creates problem Y. How do you solve it. 
- How‚Äôs your company presence in the iOS community?
- Do you feel like you have the freedom to spend time on learning?
- Have the autonomy to initiate something that wasn‚Äôt originated from a PM and ultimately have it shipped?
- When was the last time some got a promotion? What did they do stand out?
- Do you think promotions come in late?
- How does the company/manager/team help you grow?
- How soon are you to adopt the latest and greatest of iOS things.
- What‚Äôs the last big change in terms of process that you made?

### RxSwift
You should go on that you started the project with Rx, but then you ditched it. 
As as we didn't need that level of mapping stuff. Also it was difficult as our was getting converged. 
Later I started learning MVVM and got deep into writing unit-tests and stuff. Realized what's the difference between a class, it's VM, VM mock and VM Tests. 
And that it's best to not use mock clases, rather just inject a mock for its dependencies. 

### Give structured answers (Pg. 35) : 
- Situation 
- Action (try to have things in a bulleted list. I did 3 things x, y,z and explain each)
- Result 


### Intro (Pg. 36) : 
- Current role
- College 
- Post College
- Current Role
- Outside of work
- wrap up:  What you're looking for etc. 

Try to mention things that show that you're good a cultural fit...limited notes of success and stuff. 

## Big O (Pg. 43)
- time complexity
- space complexity: it's about how much space you need at a single time. i.e. if you create an array at every iteration then you need O(n). However if need N arrays before even looping then the space complexity is O(n) :üí°üí°üí°

### Sequential loops vs. Nested loops

**Sequentia O(n)**
```swift
for a in arr {
}

for b in arr {
}
```

vs. 

**Nested O(n^2)**

```swift
for a in arr {
 for b in arr {
 }
}
```

üí°üí°üí° for most tree like stuff the complexity would be number of (branches)<sup>depth</sup>. Branches/choices/options/directions. 


Looping like this is still N^2: 

```swift
for i in 0 ... n {
   for j in i + 1 ... n {
      print(i,j)
   }
}
```

It's N^2 because the first step is going to happen N - 1 times, then N -2 times, and until ... 1 . So it's `N(N-1)/2` and that's just N^2

**What's the Big O notation of sorting each string of an array and then sorting them all? (Pg. 49)**

Assuming `i` is the average lenght of each item: 

sorting each item is: `i * log(i)`. And we have `n` items. so `n * i * log(i)`
sorting all items is: `n * log(n)`. And each comparison can be of length `i * n * log(n)`
total = n * i * log<sup> i + n </sup>

Pro-tip: How many times a thing gets called. For what length. 

** What is the Big O notation of fibnoacchi (Pg. 54)?**

It's `branches ^ depth` = 2 ^ N`

What if we cache the values? 

üí°üí°üí° It's key to write it down. It turns into this:


```
f0 = 1 & store
f1 = 1 & store
f2 = c0 + c1 & store 
f3 = c2 + c1 & store
...
fn = fn-1 + fn-2 & store
```

`c1` means cache value for `f(1)`
`c8` means cache value for `f(8)`

So you basically change from computation to lookup and that changes your Big O notation...

## Technical Questions (Pg. 60)

Test your stuff with a simple:
- general case
- base case
- error case

# Steps to solve a problem

- Listen carefully 
- Draw an Example
- State brute force. Don't think that brute force is bad. A lot of candidates can't think of the brute force solution. So even talking aout that is great! (Pg. 64)
- Optimize (fresh example
  - Precompute values
  - Use hash table
  - Think of best conceivable. Often that leads you to the solution...
- **Walk your interview through the high level steps**
- Then implement
- Test
  - Hot spots: base case in recursive code
  - Special cases:
   - Empty values
   - Negative values
   - Zero
   - overflow values
   - trees that aren't balanced. 
   - start and end of an iteration
   - division by zero 
   - null nodes in trees
 - Optimize
   - Look for BUD
    - Bottlenecks: identify which step is the bottleneck
    - Unnecessary work. Example: 
      Print all positive integers that match a^3 + be ^3 = c^ + d^3 (1 < a,b,c,d < 1000)
      Unncecessary to calculate all and compare
      We can just find all values that are integers for (a^3 + b^3 + c^3) ^(1/3)
    - Duplicated work: In the above example: 
      Store all results of c^3 + d^3 in a dictionary. (No need to calculate it every time). Then every time we calculate a^3 + b^3 look up to see if we have that value in our dictionary, if so pull out c & d. **Dictionaries are usually the most common way to avoid duplicate work.**
   - DIY (Do it yourself). Without any coding do, just use your brain and do it. Then try to infer the algorithm you used. Where you skipped something or actually entered a flow and what algorithm/function you used in your head. (Pg. 70)
   - Simplify and generalize ????
   - Base case and build. Try to solve things for n = 1, then try to build up. 
     Q: How to print all permutations of a string. For simplicity assume all characters are unique. 
     A: case "a" -> "a"
        case "ab" -> "ab", "ba"
        case "abc" -> ?
        
        1. Insert "c" into all Permutations of "ab"
        2. Insert "c" into all strings of "ab" & "ba"
        3. Merge ("cab", "acb", "abc") & ("cba", "bca", "bac")
        4. ("cab", "acb", "abc", "cba", "bca", "bac")
     Base case and build often leads to recursive algorithms
     
  - Flexible and Robust:
    If tic-tac-toe is 3 x 3, well you can still build your board to be N x N (Pg.80)
  - Don't give up. Show excitements for solving hard problems

## Negotiations Pg. 82
- Have a specific ask
- Keep relationships open after people lave. 
- Keep interviewing at least 3-4 times a year

### Permutations vs combinations

A permutation is an act of arranging the objects or numbers in order. Combinations are the way of selecting the objects or numbers from a group of objects or collection, in such a way that the order of the objects does not matter. From [here](https://byjus.com/maths/permutation-and-combination/)

https://www.youtube.com/watch?v=m7chPc7zIF4&list=LL&index=66
Permutations: How many ways from A to B? 
- A total of 10 directions -> 10!
- 4 _rights_ exist as identical elements. -> / 4!
- 6 _down_ exist as identical -> / 6!
- answer = 10! / (4! * 6!) ... Total answer / total overcounts

**Mistake: Can't think of it as 10 decisions each with 2 choices. It's becaues a selection of 10 rights or 10 downs is incorrect.**

Why can't I think of it as 10 times each with 2 options hence `2^10` ? and then start correcting from there on? Why is total answers considered to be `10!`

Permutations: How many ways from A to B, that goes through C? 
Answer: ( A -> C ) * (C -> B)

<img width="397" alt="Screen Shot 2022-01-21 at 8 09 52 PM" src="https://user-images.githubusercontent.com/12160198/150618614-11d62512-0c8b-414c-8ce3-9fb53ae106b8.png">

https://www.youtube.com/watch?v=p8vIcmr_Pqo&list=LL&index=72

Permutation formula: 

(Total possibilities) / (Total overcounts) e.g. 

From A, B, C, D, E, F create 2 letter words: 6! total, but then we actually don't 6 slots. So we have to reduce our counts by dividing it by (6 - 4)!

Combination formula: Is same as permutation formula it just then reduces by the _order overcount_ as well

<img width="1435" alt="Screen Shot 2022-01-21 at 8 55 47 PM" src="https://user-images.githubusercontent.com/12160198/150620346-b3efc49c-b392-4fda-a53e-8790f0f1da5f.png">
